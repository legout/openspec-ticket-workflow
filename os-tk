#!/usr/bin/env bash
# os-tk — OpenSpec + Ticket workflow CLI
#
# Global tool installed to ~/.local/bin/os-tk
# Per-project config at .os-tk/config.json
#
# Commands:
#   os-tk init           # Initialize project: sync + apply + update AGENTS.md
#   os-tk sync           # Download .opencode/** from templateRepo@templateRef
#   os-tk apply          # Re-apply config to agents (no network, no AGENTS.md)
#   os-tk version        # Show os-tk version and project templateRef
#   os-tk --version      # Show os-tk version
#   os-tk --help         # Show usage

set -euo pipefail

# =============================================================================
# VERSION (single source of truth)
# =============================================================================
VERSION="0.2.2"

# =============================================================================
# PATHS
# =============================================================================
CONFIG_DIR=".os-tk"
CONFIG_FILE="$CONFIG_DIR/config.json"
OPENCODE_DIR=".opencode"
AGENTS_FILE="AGENTS.md"

# Markers for AGENTS.md block
MARKER_START="<!-- OS-TK-START -->"
MARKER_END="<!-- OS-TK-END -->"

# Legacy markers (for migration)
LEGACY_MARKER_START="<!-- OPENSPEC-TK-START -->"
LEGACY_MARKER_END="<!-- OPENSPEC-TK-END -->"

# =============================================================================
# DEPENDENCIES
# =============================================================================
check_dependencies() {
  if ! command -v jq &>/dev/null; then
    echo "Error: 'jq' is required but not installed."
    echo "Install with: apt install jq / brew install jq"
    exit 1
  fi
  if ! command -v curl &>/dev/null; then
    echo "Error: 'curl' is required but not installed."
    exit 1
  fi
}

# =============================================================================
# CONFIG
# =============================================================================
default_config() {
  local ref="${1:-$VERSION}"
  cat << JSON
{
  "templateRepo": "legout/openspec-ticket-opencode-starter",
  "templateRef": "v$ref",
  "useWorktrees": true,
  "worktreeDir": ".worktrees",
  "defaultParallel": 3,
  "mainBranch": "main",
  "autoPush": true,
  "unsafe": {
    "allowParallel": false,
    "allowDirtyDone": false,
    "commitStrategy": "prompt"
  },
  "planner": {
    "model": "openai/gpt-5.2",
    "reasoningEffort": "high",
    "temperature": 0
  },
  "worker": {
    "model": "zai-coding-plan/glm-4.7",
    "fallbackModels": ["minimax/MiniMax-M2.1"],
    "reasoningEffort": "none",
    "temperature": 0.2
  },
  "reviewer": {
    "model": "openai/gpt-5.2",
    "reasoningEffort": "high",
    "temperature": 0,
    "autoTrigger": false,
    "categories": ["spec-compliance", "tests", "security", "quality"],
    "createTicketsFor": ["error"],
    "skipTags": ["no-review", "wip"]
  }
}
JSON
}

load_config() {
  if [[ ! -f "$CONFIG_FILE" ]]; then
    echo "Error: Config file not found: $CONFIG_FILE"
    echo "Run 'os-tk init' first, or check you're in a project root."
    exit 1
  fi
  cat "$CONFIG_FILE"
}

get_config_value() {
  local config="$1"
  local key="$2"
  local default="${3:-}"
  local value
  value=$(echo "$config" | jq -r "$key // empty")
  if [[ -z "$value" || "$value" == "null" ]]; then
    echo "$default"
  else
    echo "$value"
  fi
}

# =============================================================================
# TEMPLATE REF RESOLUTION
# =============================================================================
resolve_template_ref() {
  local config="$1"
  local ref
  ref=$(get_config_value "$config" '.templateRef' 'latest')
  
  if [[ "$ref" == "latest" ]]; then
    local repo
    repo=$(get_config_value "$config" '.templateRepo' 'legout/openspec-ticket-opencode-starter')
    
    echo "Resolving 'latest' from GitHub releases..." >&2
    
    # Follow redirect to get latest release tag
    local redirect_url
    redirect_url=$(curl -sI "https://github.com/$repo/releases/latest" 2>/dev/null | grep -i '^location:' | tr -d '\r' | awk '{print $2}')
    
    if [[ -n "$redirect_url" ]]; then
      ref=$(basename "$redirect_url")
      echo "Resolved 'latest' to: $ref" >&2
    else
      echo "Warning: Could not resolve 'latest', falling back to 'main'" >&2
      ref="main"
    fi
  fi
  
  echo "$ref"
}

# =============================================================================
# SYNC: Download files from template repo for each agent platform
# =============================================================================

# OpenCode files (canonical source)
OPENCODE_FILES=(
  "agent/os-tk-planner.md"
  "agent/os-tk-worker.md"
  "agent/os-tk-reviewer.md"
  "command/os-breakdown.md"
  "command/os-change.md"
  "command/os-proposal.md"
  "command/tk-bootstrap.md"
  "command/tk-done.md"
  "command/tk-queue.md"
  "command/tk-refactor.md"
  "command/tk-review.md"
  "command/tk-run.md"
  "command/tk-start.md"
  "skill/openspec/SKILL.md"
  "skill/ticket/SKILL.md"
  "skill/os-tk-workflow/SKILL.md"
)

# Claude Code files
CLAUDE_FILES=(
  "agents/planner.md"
  "agents/worker.md"
  "agents/reviewer.md"
  "commands/os/breakdown.md"
  "commands/os/change.md"
  "commands/os/proposal.md"
  "commands/tk/bootstrap.md"
  "commands/tk/start.md"
  "commands/tk/done.md"
  "commands/tk/queue.md"
  "commands/tk/review.md"
  "commands/tk/run.md"
  "commands/tk/refactor.md"
  "skills/openspec/SKILL.md"
  "skills/ticket/SKILL.md"
  "skills/os-tk-workflow/SKILL.md"
)

# Factory/Droid files
DROID_FILES=(
  "droids/planner.md"
  "droids/worker.md"
  "droids/reviewer.md"
  "commands/os-breakdown.md"
  "commands/os-change.md"
  "commands/os-proposal.md"
  "commands/tk-bootstrap.md"
  "commands/tk-start.md"
  "commands/tk-done.md"
  "commands/tk-queue.md"
  "commands/tk-review.md"
  "commands/tk-run.md"
  "commands/tk-refactor.md"
  "skills/openspec/SKILL.md"
  "skills/ticket/SKILL.md"
  "skills/os-tk-workflow/SKILL.md"
)

# Universal .agent files
UNIVERSAL_FILES=(
  "agents/planner.md"
  "agents/worker.md"
  "agents/reviewer.md"
  "commands/os-breakdown.md"
  "commands/os-change.md"
  "commands/os-proposal.md"
  "commands/tk-bootstrap.md"
  "commands/tk-start.md"
  "commands/tk-done.md"
  "commands/tk-queue.md"
  "commands/tk-review.md"
  "commands/tk-run.md"
  "commands/tk-refactor.md"
  "skills/openspec.md"
  "skills/ticket.md"
  "skills/os-tk-workflow.md"
)

# Default agent platforms (comma-separated)
DEFAULT_AGENTS="opencode"

# Parse --agent flag and return array of agents
parse_agents() {
  local input="${1:-$DEFAULT_AGENTS}"
  
  # Handle "all" keyword
  if [[ "$input" == "all" ]]; then
    echo "opencode,claude,droid,universal"
    return
  fi
  
  # Validate each agent
  local IFS=','
  for agent in $input; do
    case "$agent" in
      opencode|claude|droid|universal) ;;
      *)
        echo "Error: Unknown agent platform: $agent" >&2
        echo "Valid options: opencode, claude, droid, universal, all" >&2
        exit 1
        ;;
    esac
  done
  
  echo "$input"
}

# Get target directory for an agent platform
get_agent_dir() {
  local agent="$1"
  case "$agent" in
    opencode)  echo ".opencode" ;;
    claude)    echo ".claude" ;;
    droid)     echo ".factory" ;;
    universal) echo ".agent" ;;
    *)
      echo "Error: Unknown agent: $agent" >&2
      return 1
      ;;
  esac
}

# Get source directory in template repo for an agent platform
get_template_dir() {
  local agent="$1"
  case "$agent" in
    opencode)  echo ".opencode" ;;
    claude)    echo ".claude" ;;
    droid)     echo ".factory" ;;
    universal) echo ".agent" ;;
    *)
      echo "Error: Unknown agent: $agent" >&2
      return 1
      ;;
  esac
}

# Get file array for an agent platform
get_agent_files() {
  local agent="$1"
  case "$agent" in
    opencode)  echo "${OPENCODE_FILES[@]}" ;;
    claude)    echo "${CLAUDE_FILES[@]}" ;;
    droid)     echo "${DROID_FILES[@]}" ;;
    universal) echo "${UNIVERSAL_FILES[@]}" ;;
    *)
      echo "Error: Unknown agent: $agent" >&2
      return 1
      ;;
  esac
}

# Sync files for a single agent platform
sync_agent_platform() {
  local agent="$1"
  local base_url="$2"
  
  local target_dir template_dir
  target_dir=$(get_agent_dir "$agent")
  template_dir=$(get_template_dir "$agent")
  
  echo "Syncing $agent → $target_dir/"
  
  # Get file list based on agent
  local files
  case "$agent" in
    opencode)  files=("${OPENCODE_FILES[@]}") ;;
    claude)    files=("${CLAUDE_FILES[@]}") ;;
    droid)     files=("${DROID_FILES[@]}") ;;
    universal) files=("${UNIVERSAL_FILES[@]}") ;;
  esac
  
  # Create all required directories
  for file in "${files[@]}"; do
    local dir
    dir=$(dirname "$target_dir/$file")
    mkdir -p "$dir"
  done
  
  # Download files
  local failed=0
  for file in "${files[@]}"; do
    local url="$base_url/$template_dir/$file"
    local dest="$target_dir/$file"
    
    if curl -sSfL "$url" -o "$dest" 2>/dev/null; then
      echo "  [ok] $dest"
    else
      echo "  [FAIL] $dest"
      ((failed++)) || true
    fi
  done
  
  if [[ $failed -gt 0 ]]; then
    echo "  Warning: $failed file(s) failed for $agent"
  fi
  
  return $failed
}

cmd_sync() {
  check_dependencies
  
  local agents_input="$DEFAULT_AGENTS"
  
  # Parse flags
  while [[ $# -gt 0 ]]; do
    case "$1" in
      --agent|-a)
        agents_input="$2"
        shift 2
        ;;
      *)
        echo "Unknown option for sync: $1"
        usage
        ;;
    esac
  done
  
  local agents
  agents=$(parse_agents "$agents_input")
  
  local config
  config=$(load_config)
  
  local repo
  repo=$(get_config_value "$config" '.templateRepo' 'legout/openspec-ticket-opencode-starter')
  
  local ref
  ref=$(resolve_template_ref "$config")
  
  local base_url="https://raw.githubusercontent.com/$repo/$ref"
  
  echo "Syncing from $repo@$ref"
  echo "Agents: $agents"
  echo ""
  
  # Sync each selected agent platform
  local total_failed=0
  local IFS=','
  for agent in $agents; do
    sync_agent_platform "$agent" "$base_url"
    ((total_failed += $?)) || true
    echo ""
  done
  
  if [[ $total_failed -gt 0 ]]; then
    echo "Warning: Some files failed to download."
    echo "Check that templateRef '$ref' exists and contains all required files."
  fi
  
  echo "Sync complete."
  
  # Also update AGENTS.md block
  echo ""
  update_agents_md
}

# =============================================================================
# AGENTS.MD: Update the OS-TK block
# =============================================================================
AGENTS_BLOCK='<!-- OS-TK-START -->
# Agent Workflow: OpenSpec + Ticket (tk)

This repo uses OpenSpec for spec-driven changes and tk for task execution tracking.

## Core Rules

1. **Specs before code** - Create an OpenSpec proposal before implementing.
2. **One change = one epic** - Create a tk epic with `--external-ref "openspec:<change-id>"`.
3. **3-8 chunky tickets** - Break work into deliverables (DB/API/UI/tests/docs).
4. **Queue-driven execution** - Pick work via `tk ready`, never blind implementation.
5. **`/tk-done` is mandatory** - Always use `/tk-done` to close work (syncs tasks + archives + merges + pushes).

## Commands

| Command | Purpose |
|---------|---------|
| `/os-breakdown <source> [--with-tickets]` | Break down PRD/plan into OpenSpec proposals |
| `/os-proposal <id>` | Create/update OpenSpec change files |
| `/os-change [id]` | View change status (view-only) |
| `/tk-bootstrap <change-id> "<title>"` | Create tk epic + tasks from OpenSpec change |
| `/tk-queue [next\\|all\\|<change-id>]` | Show ready/blocked tickets (view-only) |
| `/tk-start <id...> [--parallel N]` | Start ticket(s) and implement |
| `/tk-done <id> [change-id]` | Close + sync + archive + merge + push |
| `/tk-review <id>` | Review completed ticket, create fix tickets if needed |
| `/tk-run [--all] [--max-cycles N]` | Autonomous loop: start → done → review → repeat |
| `/tk-refactor` | Merge duplicates, clean up backlog (optional) |

## Review Automation

- `/tk-review` analyzes merge commits against OpenSpec specs
- Creates linked fix tickets (non-blocking) for issues found
- Configure via `reviewer` section in `.os-tk/config.json`
- `/tk-run` enables fully autonomous operation (Ralph mode)

## Parallel Execution

- **Safe mode** (`useWorktrees: true`): Parallel via git worktrees, isolated branches.
- **Simple mode** (`useWorktrees: false`): Single working tree; parallel only if `unsafe.allowParallel: true`.

Configure via `.os-tk/config.json`. Initialize with `os-tk init`.
<!-- OS-TK-END -->'

update_agents_md() {
  echo "Updating AGENTS.md..."
  
  if [[ ! -f "$AGENTS_FILE" ]]; then
    echo "  Creating new AGENTS.md"
    echo "$AGENTS_BLOCK" > "$AGENTS_FILE"
    return
  fi
  
  local content
  content=$(cat "$AGENTS_FILE")
  
  # Check for new markers
  if grep -qF "$MARKER_START" "$AGENTS_FILE"; then
    echo "  Replacing existing OS-TK block"
    # Remove old block and append new one
    perl -i -0pe "s/\Q$MARKER_START\E.*?\Q$MARKER_END\E//gs" "$AGENTS_FILE"
    # Remove trailing blank lines then append
    sed -i -e :a -e '/^\n*$/{$d;N;ba' -e '}' "$AGENTS_FILE" 2>/dev/null || true
    echo "" >> "$AGENTS_FILE"
    echo "$AGENTS_BLOCK" >> "$AGENTS_FILE"
    return
  fi
  
  # Check for legacy markers (migration)
  if grep -qF "$LEGACY_MARKER_START" "$AGENTS_FILE"; then
    echo "  Migrating from legacy OPENSPEC-TK markers to OS-TK markers"
    perl -i -0pe "s/\Q$LEGACY_MARKER_START\E.*?\Q$LEGACY_MARKER_END\E//gs" "$AGENTS_FILE"
    sed -i -e :a -e '/^\n*$/{$d;N;ba' -e '}' "$AGENTS_FILE" 2>/dev/null || true
    echo "" >> "$AGENTS_FILE"
    echo "$AGENTS_BLOCK" >> "$AGENTS_FILE"
    return
  fi
  
  # No markers exist - append
  echo "  Appending OS-TK block"
  echo "" >> "$AGENTS_FILE"
  echo "$AGENTS_BLOCK" >> "$AGENTS_FILE"
}

# =============================================================================
# APPLY: Regenerate agent files from config (no network, no AGENTS.md)
# =============================================================================
rebuild_agent_from_template() {
  local agent_file="$1"
  local role="$2"
  local model="$3"
  local temperature="$4"
  local reasoning_effort="$5"
  
  # Different permissions for each role
  local edit_perm="allow"
  local write_perm="allow"
  if [[ "$role" == "planner" ]]; then
    # Planner can create tickets (edit AGENTS.md) but contract restricts code editing
    edit_perm="allow"
    write_perm="allow"
  elif [[ "$role" == "reviewer" ]]; then
    # Reviewer can run tk commands but not edit code files
    edit_perm="deny"
    write_perm="deny"
  fi
  
  # Build optional reasoningEffort line (skip if empty, null, or "none")
  local reasoning_line=""
  local lower_effort
  lower_effort=$(echo "$reasoning_effort" | tr '[:upper:]' '[:lower:]')
  if [[ -n "$reasoning_effort" && "$reasoning_effort" != "null" && "$lower_effort" != "none" ]]; then
    reasoning_line="reasoningEffort: ${reasoning_effort}"
  fi
  
  cat > "$agent_file" << AGENT
---
name: os-tk-${role}
description: OpenSpec + ticket ${role} (view-only vs execution)
model: ${model}
mode: subagent
temperature: ${temperature}
${reasoning_line}
permission:
  bash: allow
  skill: allow
  edit: ${edit_perm}
  write: ${write_perm}
---

# OpenSpec + Ticket ${role}

You implement the ${role} phase of the workflow.

AGENT

  if [[ "$role" == "planner" ]]; then
    cat >> "$agent_file" << 'AGENT'

You coordinate **planning, bootstrapping, and orchestration** phases of the workflow. You **NEVER implement code** but you CAN create tickets and spawn worker subtasks.

## Core Responsibilities

1. **Planning** - Analyze specs, view status, recommend actions
2. **Bootstrapping** - Design and create 3-8 chunky tickets per epic
3. **Orchestration** - Spawn parallel worker subtasks for execution

## Command Precedence

When invoked via a command (e.g., `/os-change`, `/tk-queue`, `/tk-bootstrap`):
- The command markdown file is the HIGHEST PRIORITY contract.
- If any conflict between this description, skills, or general rules and the command's contract:
  - **The command contract wins. Always.**
- If a command says STOP -> you STOP.

## Allowed Actions

| Category | Commands |
|----------|----------|
| **OpenSpec** | `openspec list`, `openspec show <id>`, `openspec validate <id>` |
| **Tickets (read)** | `tk ready`, `tk blocked`, `tk show <id>`, `tk query <filter>` |
| **Tickets (write)** | `tk create`, `tk dep`, `tk link` |
| **AGENTS.md** | Edit **only within** `<!-- OS-TK-START -->` / `<!-- OS-TK-END -->` markers |
| **Subtasks** | Spawn `os-tk-worker` subtasks for parallel execution |
| **Analysis** | Summarize, analyze, recommend |

## Forbidden Actions

- `tk start`, `tk close`, `tk add-note` (those belong to worker or /tk-done)
- Editing code files (*.py, *.ts, *.js, *.go, etc.)
- Editing config files (*.json, *.yaml, etc.) except AGENTS.md markers
- Implementing features or writing application code
- Archiving OpenSpec (handled by /tk-done)
- Running tests

## Ticket Design Guidelines

When bootstrapping (/tk-bootstrap), create 3-8 chunky tickets:

| Layer | Example Ticket |
|-------|----------------|
| Data | "Database schema for User entity" |
| Backend | "User CRUD API endpoints" |
| Frontend | "User management UI components" |
| Integration | "Connect user forms to API" |
| Tests | "E2E tests for user workflows" |
| Docs | "API documentation for users" |

## Parallel Worker Spawning

For commands like `/tk-start T-001 T-002 --parallel 2`:
1. Validate tickets are ready via `tk ready`
2. Spawn one `os-tk-worker` subtask per ticket
3. Each worker operates in its own worktree (if enabled)
4. Report status when all workers complete

## Self-Check (Before Responding)

Before responding, confirm you did NOT:
- [ ] Write or suggest implementation code
- [ ] Propose running `tk start` or `tk close` directly
- [ ] Edit code files or config files (except AGENTS.md markers)

If you violated any, remove it and redirect to `/tk-start` or `/tk-done`.

## Worktree Awareness

- Exclude active worktrees (`.worktrees/<id>/`) from "ready to start" lists
- When `useWorktrees` is false, all "ready" tickets are eligible
AGENT

  elif [[ "$role" == "worker" ]]; then
    cat >> "$agent_file" << 'AGENT'

You implement **ticket deliverables and acceptance criteria** within isolated contexts.

## Core Rules

- Implement exactly one ticket per invocation.
- Run tests to validate implementation.
- Do NOT close tickets (that is `/tk-done`'s job).
- Do NOT archive OpenSpec (that is `/tk-done`'s job).
- Do NOT merge branches or push (those are `/tk-done`'s job).
- Edit OpenSpec `tasks.md` only as directed by planner/`/tk-done` sync.

## Allowed Actions

- Edit files, write code, refactor as needed.
- Run tests and fix failures.
- Read `tk show <id>` for ticket context.

## Forbidden Actions

- Closing tickets (`tk close`)
- Archiving OpenSpec
- Merging branches or pushing
- Editing OpenSpec `tasks.md` (that is planner/`/tk-done`'s sync job)
- Implementing multiple tickets in one flow

## Worktree Awareness

- When `useWorktrees` is true, you operate in an isolated worktree: `.worktrees/<ticket-id>/`.
- When `useWorktrees` is false, you operate in the current working tree.

## Output

When implementation is complete:
- Summarize what was implemented.
- List any files created/modified.
- Explicitly instruct the user to run `/tk-done <id> [change-id]`.
AGENT

  elif [[ "$role" == "reviewer" ]]; then
    cat >> "$agent_file" << 'AGENT'

You perform **post-implementation code review** analyzing completed work for quality issues.

## Core Rules

- Analyze git diffs and compare against OpenSpec specs.
- Add review notes to tickets via `tk add-note`.
- Create fix tickets via `tk create` and link them via `tk link`.
- Never edit code files directly.
- Never close tickets or start implementation.

## Review Categories

1. **spec-compliance**: Does implementation match OpenSpec requirements?
2. **tests**: Are acceptance criteria covered by tests?
3. **security**: Obvious vulnerabilities (injection, auth, secrets)
4. **quality**: Code patterns, DRY violations, error handling

## Allowed Actions

- Read all files, specs, and ticket data
- `git diff`, `git log`, `git show` to analyze changes
- `tk add-note <id>` to add review summary
- `tk create` to create fix tickets
- `tk link` to link fix tickets to originals
- `openspec show`, `openspec list` to read specs

## Forbidden Actions

- Editing code files (*.py, *.ts, *.js, etc.)
- `tk start`, `tk close`
- Implementing fixes (that's the worker's job)
- Archiving OpenSpec

## Output Format

Review notes should follow this format:

```markdown
## Review (YYYY-MM-DD)
✅ spec-compliance: passed
⚠️ tests: Missing edge case test for null input
❌ security: SQL injection risk in query builder

Created: T-XXX (linked)
```

When review is complete:
- Summarize findings by category
- List any fix tickets created
- If no issues: "Review passed, no issues found"
AGENT

  else
    echo "Error: Unknown role: $role"
    exit 1
  fi
}

ensure_gitignore_worktrees() {
  local config="$1"
  local use_worktrees
  use_worktrees=$(get_config_value "$config" '.useWorktrees' 'false')
  
  if [[ "$use_worktrees" == "true" ]]; then
    local worktree_dir
    worktree_dir=$(get_config_value "$config" '.worktreeDir' '.worktrees')
    local gitignore_entry="${worktree_dir}/"
    
    if [[ ! -f ".gitignore" ]]; then
      echo "$gitignore_entry" > .gitignore
      echo "Created .gitignore with $gitignore_entry"
    elif ! grep -qF "$gitignore_entry" .gitignore 2>/dev/null; then
      echo "$gitignore_entry" >> .gitignore
      echo "Added $gitignore_entry to .gitignore"
    else
      echo "$gitignore_entry already in .gitignore"
    fi
  fi
}

cmd_apply() {
  check_dependencies
  
  local agents_input=""
  
  # Parse flags
  while [[ $# -gt 0 ]]; do
    case "$1" in
      --agent|-a)
        agents_input="$2"
        shift 2
        ;;
      *)
        echo "Unknown option for apply: $1"
        usage
        ;;
    esac
  done
  
  local config
  config=$(load_config)
  
  # Get agents from flag, config, or default
  if [[ -z "$agents_input" ]]; then
    agents_input=$(get_config_value "$config" '.agents' "$DEFAULT_AGENTS")
  fi
  
  local agents
  agents=$(parse_agents "$agents_input")
  
  echo "Applying config to agents: $agents"
  echo ""
  
  # Extract planner config
  local planner_model planner_temp planner_reasoning
  planner_model=$(get_config_value "$config" '.planner.model' 'openai/gpt-5.2')
  planner_temp=$(get_config_value "$config" '.planner.temperature' '0')
  planner_reasoning=$(get_config_value "$config" '.planner.reasoningEffort' '')
  
  # Extract worker config
  local worker_model worker_temp worker_reasoning
  worker_model=$(get_config_value "$config" '.worker.model' 'zai-coding-plan/glm-4.7')
  worker_temp=$(get_config_value "$config" '.worker.temperature' '0.2')
  worker_reasoning=$(get_config_value "$config" '.worker.reasoningEffort' '')
  
  # Extract reviewer config (uses planner model by default)
  local reviewer_model reviewer_temp reviewer_reasoning
  reviewer_model=$(get_config_value "$config" '.reviewer.model' "$planner_model")
  reviewer_temp=$(get_config_value "$config" '.reviewer.temperature' '0')
  reviewer_reasoning=$(get_config_value "$config" '.reviewer.reasoningEffort' "$planner_reasoning")
  
  # Apply to each selected agent platform
  local IFS=','
  for agent in $agents; do
    apply_agent_platform "$agent" \
      "$planner_model" "$planner_temp" "$planner_reasoning" \
      "$worker_model" "$worker_temp" "$worker_reasoning" \
      "$reviewer_model" "$reviewer_temp" "$reviewer_reasoning"
  done
  
  ensure_gitignore_worktrees "$config"
  
  echo ""
  echo "Config applied."
}

# Apply config to a specific agent platform
apply_agent_platform() {
  local agent="$1"
  local planner_model="$2" planner_temp="$3" planner_reasoning="$4"
  local worker_model="$5" worker_temp="$6" worker_reasoning="$7"
  local reviewer_model="$8" reviewer_temp="$9" reviewer_reasoning="${10}"
  
  local target_dir
  target_dir=$(get_agent_dir "$agent")
  
  echo "Applying to $agent → $target_dir/"
  
  case "$agent" in
    opencode)
      mkdir -p "$target_dir/agent"
      rebuild_agent_from_template "$target_dir/agent/os-tk-planner.md" "planner" "$planner_model" "$planner_temp" "$planner_reasoning"
      rebuild_agent_from_template "$target_dir/agent/os-tk-worker.md" "worker" "$worker_model" "$worker_temp" "$worker_reasoning"
      rebuild_agent_from_template "$target_dir/agent/os-tk-reviewer.md" "reviewer" "$reviewer_model" "$reviewer_temp" "$reviewer_reasoning"
      echo "  - $target_dir/agent/os-tk-planner.md (model: $planner_model)"
      echo "  - $target_dir/agent/os-tk-worker.md (model: $worker_model)"
      echo "  - $target_dir/agent/os-tk-reviewer.md (model: $reviewer_model)"
      ;;
    claude)
      # Claude Code uses different structure - agents are in agents/ dir
      # Config is applied via settings.json, not embedded in agent files
      echo "  Note: Claude Code agents configured via settings.json"
      echo "  Agent files synced but model config not embedded"
      ;;
    droid)
      # Factory/Droid uses droids/ dir with reasoningEffort in frontmatter
      # Config would need to update the frontmatter in droid files
      echo "  Note: Factory/Droid agents use frontmatter config"
      echo "  Agent files synced but model config not auto-updated"
      ;;
    universal)
      # Universal format - agents are in agents/ dir
      echo "  Note: Universal agents synced, platform-agnostic format"
      ;;
  esac
  echo ""
}

# =============================================================================
# INIT: Full initialization (sync + apply + AGENTS.md)
# =============================================================================
cmd_init() {
  check_dependencies
  
  local mode="worktree"  # default
  local agents_input="$DEFAULT_AGENTS"
  
  # Parse flags
  while [[ $# -gt 0 ]]; do
    case "$1" in
      --worktree|worktree)
        mode="worktree"
        shift
        ;;
      --simple|simple)
        mode="simple"
        shift
        ;;
      --agent|-a)
        agents_input="$2"
        shift 2
        ;;
      *)
        echo "Unknown option: $1"
        usage
        ;;
    esac
  done
  
  # Validate agents early
  local agents
  agents=$(parse_agents "$agents_input")
  
  # Create config if missing
  if [[ ! -f "$CONFIG_FILE" ]]; then
    mkdir -p "$CONFIG_DIR"
    default_config "$VERSION" > "$CONFIG_FILE"
    echo "Created default config: $CONFIG_FILE"
  else
    echo "Config already exists: $CONFIG_FILE (preserving existing values)"
  fi
  
  # Store selected agents in config
  jq --arg agents "$agents" '.agents = $agents' "$CONFIG_FILE" > "${CONFIG_FILE}.tmp" && mv "${CONFIG_FILE}.tmp" "$CONFIG_FILE"
  
  # Apply mode
  if [[ "$mode" == "worktree" ]]; then
    echo "Enabling worktree mode (safe parallel)..."
    jq ".useWorktrees = true" "$CONFIG_FILE" > "${CONFIG_FILE}.tmp" && mv "${CONFIG_FILE}.tmp" "$CONFIG_FILE"
  elif [[ "$mode" == "simple" ]]; then
    echo "Enabling simple mode (no worktrees)..."
    jq ".useWorktrees = false" "$CONFIG_FILE" > "${CONFIG_FILE}.tmp" && mv "${CONFIG_FILE}.tmp" "$CONFIG_FILE"
  fi
  
  echo ""
  
  # Sync agent files from template
  cmd_sync --agent "$agents"
  
  echo ""
  
  # Apply config to agents
  cmd_apply --agent "$agents"
  
  echo ""
  
  # Update AGENTS.md
  update_agents_md
  
  echo ""
  echo "os-tk initialized!"
  echo ""
  echo "Selected agents: $agents"
  echo ""
  echo "Next steps:"
  echo "  1. Review and edit .os-tk/config.json to customize models/settings"
  echo "  2. Run: os-tk apply  (to regenerate agents after config changes)"
  
  # Build commit message based on selected agents
  local dirs=".os-tk AGENTS.md .gitignore"
  local IFS=','
  for agent in $agents; do
    local dir
    dir=$(get_agent_dir "$agent")
    dirs="$dirs $dir"
  done
  echo "  3. Commit: git add $dirs"
  echo ""
}

# =============================================================================
# VERSION
# =============================================================================
cmd_version() {
  echo "os-tk version $VERSION"
  
  if [[ -f "$CONFIG_FILE" ]]; then
    local config
    config=$(cat "$CONFIG_FILE")
    local template_ref
    template_ref=$(get_config_value "$config" '.templateRef' 'not set')
    local template_repo
    template_repo=$(get_config_value "$config" '.templateRepo' 'not set')
    echo ""
    echo "Project config:"
    echo "  templateRepo: $template_repo"
    echo "  templateRef:  $template_ref"
  fi
}

# =============================================================================
# USAGE
# =============================================================================
usage() {
  cat << EOF
os-tk — OpenSpec + Ticket workflow CLI

Usage: os-tk <command> [options]

Commands:
  init [options]          Initialize project (sync + apply + update AGENTS.md)
  sync [options]          Download agent files from templateRepo@templateRef
  apply [options]         Re-apply config to agents (no network, no AGENTS.md)
  version                 Show os-tk version and project templateRef

Agent Platforms:
  opencode                OpenCode format (.opencode/) - default
  claude                  Claude Code format (.claude/)
  droid                   Factory/Droid format (.factory/)
  universal               Universal format (.agent/)
  all                     All platforms

Options:
  --agent, -a <platforms> Comma-separated agent platforms (default: opencode)
  --worktree              Enable worktree mode for parallel execution (default)
  --simple                Disable worktrees, single working tree
  --version               Show version only
  --help                  Show this help

Config:
  Per-project config is stored in: .os-tk/config.json
  Set templateRef to a tag (e.g., "v1.0.0") or "latest" for newest release.

Examples:
  os-tk init                              # Initialize with OpenCode only
  os-tk init --agent opencode,claude      # Initialize for OpenCode + Claude Code
  os-tk init --agent all                  # Initialize for all platforms
  os-tk init --simple --agent claude      # Claude Code without worktrees
  os-tk sync --agent opencode,droid       # Update OpenCode + Factory files
  os-tk apply                             # Regenerate agents (uses config)
  os-tk apply --agent claude              # Regenerate Claude agents only

EOF
  exit 0
}

# =============================================================================
# MAIN
# =============================================================================
main() {
  local command="${1:-}"
  
  case "$command" in
    init)
      shift
      cmd_init "$@"
      ;;
    sync)
      shift
      cmd_sync "$@"
      ;;
    apply)
      shift
      cmd_apply "$@"
      ;;
    version)
      cmd_version
      ;;
    --version|-v)
      echo "os-tk $VERSION"
      ;;
    --help|-h|help|"")
      usage
      ;;
    *)
      echo "Unknown command: $command"
      echo ""
      usage
      ;;
  esac
}

main "$@"
