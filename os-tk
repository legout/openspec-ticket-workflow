#!/usr/bin/env bash
# os-tk — OpenSpec + Ticket workflow CLI
#
# Global tool installed to ~/.local/bin/os-tk
# Per-project config at config.json
#
# Commands:
#   os-tk init           # Initialize project: sync + apply + update AGENTS.md
#   os-tk sync           # Download opencode/** from templateRepo@templateRef
#   os-tk apply          # Re-apply config to agents (no network, no AGENTS.md)
#   os-tk version        # Show os-tk version and project templateRef
#   os-tk --version      # Show os-tk version
#   os-tk --help         # Show usage

set -euo pipefail

# =============================================================================
# VERSION (single source of truth)
# =============================================================================
VERSION="0.5.0"

# =============================================================================
# PATHS
# =============================================================================
CONFIG_DIR="."
CONFIG_FILE="config.json"
OPENCODE_DIR=".opencode"
AGENTS_FILE="AGENTS.md"

# Markers for AGENTS.md block
MARKER_START="<!-- OS-TK-START -->"
MARKER_END="<!-- OS-TK-END -->"

# Legacy markers (for migration)
LEGACY_MARKER_START="<!-- OPENSPEC-TK-START -->"
LEGACY_MARKER_END="<!-- OPENSPEC-TK-END -->"

# =============================================================================
# DEPENDENCIES
# =============================================================================
check_dependencies() {
  if ! command -v jq &>/dev/null; then
    echo "Error: 'jq' is required but not installed."
    echo "Install with: apt install jq / brew install jq"
    exit 1
  fi
  if ! command -v curl &>/dev/null; then
    echo "Error: 'curl' is required but not installed."
    exit 1
  fi
}

# =============================================================================
# CONFIG
# =============================================================================
default_config() {
  local ref="${1:-$VERSION}"
  local agents="${2:-opencode}"
  
  local scouts_block=""
  local adaptive_block=""
  local agg_strong_block=""

  # Multi-model review is OpenCode exclusive
  if [[ ",$agents," == *",opencode,"* ]]; then
    scouts_block='
    "scouts": [
      { "id": "opus45", "model": "google/antigravity-claude-opus-4-5-thinking", "reasoningEffort": "max", "temperature": 0 },
      { "id": "gpt52",  "model": "openai/gpt-5.2-codex", "reasoningEffort": "high", "temperature": 0 },
      { "id": "mini",   "model": "openai/gpt-5.1-codex-mini", "reasoningEffort": "high", "temperature": 0 },
      { "id": "grok",   "model": "opencode/grok-fast", "reasoningEffort": "none", "temperature": 0 }
    ],'
    adaptive_block='
    "adaptive": {
      "enabled": true,
      "maxParallelScouts": 3,
      "thresholds": {
        "small":  { "maxFiles": 4,  "maxChangedLines": 200 },
        "medium": { "maxFiles": 12, "maxChangedLines": 800 }
      },
      "defaults": {
        "small":  ["grok", "mini"],
        "medium": ["grok", "gpt52"],
        "large":  ["grok", "gpt52", "opus45"]
      }
    },'
    agg_strong_block='
    "aggregatorStrong": {
      "model": "openai/gpt-5.2",
      "reasoningEffort": "medium",
      "temperature": 0
    }'
  fi

  # Clean up trailing commas if blocks are omitted
  if [[ -z "$agg_strong_block" ]]; then
    # If agg_strong is omitted, the previous line (skipTags) needs to lose its comma
    # but since we're building the JSON here, we'll just structure it carefully.
    local reviewer_core='
    "autoTrigger": false,
    "categories": ["spec-compliance", "tests", "security", "quality"],
    "createTicketsFor": ["error"],
    "skipTags": ["no-review", "wip"]'
  else
    local reviewer_core='
    "autoTrigger": false,
    "categories": ["spec-compliance", "tests", "security", "quality"],
    "createTicketsFor": ["error"],
    "skipTags": ["no-review", "wip"],'
  fi

  cat << JSON
{
  "templateRepo": "legout/openspec-ticket-opencode-starter",
  "templateRef": "v$ref",
  "useWorktrees": true,
  "worktreeDir": ".worktrees",
  "defaultParallel": 3,
  "mainBranch": "main",
  "autoPush": true,
  "unsafe": {
    "allowParallel": false,
    "allowDirtyDone": false,
    "commitStrategy": "prompt"
  },
  "planner": {
    "model": "openai/gpt-5.2",
    "reasoningEffort": "high",
    "temperature": 0
  },
  "worker": {
    "model": "zai-coding-plan/glm-4.7",
    "fallbackModels": ["minimax/MiniMax-M2.1"],
    "reasoningEffort": "none",
    "temperature": 0.2
  },
  "reviewer": {${reviewer_core}${scouts_block}${adaptive_block}${agg_strong_block}
  }
}
JSON
}

load_config() {
  if [[ ! -f "$CONFIG_FILE" ]]; then
    echo "Error: Config file not found: $CONFIG_FILE"
    echo "Run 'os-tk init' first, or check you're in a project root."
    exit 1
  fi
  cat "$CONFIG_FILE"
}

get_config_value() {
  local config="$1"
  local key="$2"
  local default="${3:-}"
  local value
  value=$(echo "$config" | jq -r "$key // empty")
  if [[ -z "$value" || "$value" == "null" ]]; then
    echo "$default"
  else
    echo "$value"
  fi
}

# =============================================================================
# TEMPLATE REF RESOLUTION
# =============================================================================
resolve_template_ref() {
  local config="$1"
  local ref
  ref=$(get_config_value "$config" '.templateRef' 'latest')
  
  if [[ "$ref" == "latest" ]]; then
    local repo
    repo=$(get_config_value "$config" '.templateRepo' 'legout/openspec-ticket-opencode-starter')
    
    echo "Resolving 'latest' from GitHub releases..." >&2
    
    # Follow redirect to get latest release tag
    local redirect_url
    redirect_url=$(curl -sI "https://github.com/$repo/releases/latest" 2>/dev/null | grep -i '^location:' | tr -d '\r' | awk '{print $2}')
    
    if [[ -n "$redirect_url" ]]; then
      ref=$(basename "$redirect_url")
      echo "Resolved 'latest' to: $ref" >&2
    else
      echo "Warning: Could not resolve 'latest', falling back to 'main'" >&2
      ref="main"
    fi
  fi
  
  echo "$ref"
}

# =============================================================================
# SYNC: Download files from template repo for each agent platform
# =============================================================================

# OpenCode files (canonical source)
OPENCODE_FILES=(
  "agent/os-tk-planner.md"
  "agent/os-tk-worker.md"
  "agent/os-tk-reviewer.md"
  "agent/os-tk-reviewer-agg-fast.md"
  "agent/os-tk-reviewer-agg-strong.md"
  "agent/os-tk-agent-spec.md"
  "agent/os-tk-agent-design.md"
  "agent/os-tk-agent-safety.md"
  "agent/os-tk-agent-scout.md"
  "agent/os-tk-agent-quality.md"
  "agent/os-tk-agent-simplify.md"
  "command/os-breakdown.md"
  "command/os-change.md"
  "command/os-proposal.md"
  "command/tk-bootstrap.md"
  "command/tk-done.md"
  "command/tk-queue.md"
  "command/tk-refactor.md"
  "command/tk-review.md"
  "command/tk-review-fast.md"
  "command/tk-review-strong.md"
  "command/tk-run.md"
  "command/tk-start.md"
  "skill/openspec/SKILL.md"
  "skill/ticket/SKILL.md"
  "skill/os-tk-workflow/SKILL.md"
)

# Claude Code files
CLAUDE_FILES=(
  "agents/os-tk-planner.md"
  "agents/os-tk-worker.md"
  "agents/os-tk-reviewer.md"
  "agents/os-tk-agent-spec.md"
  "agents/os-tk-agent-design.md"
  "agents/os-tk-agent-safety.md"
  "agents/os-tk-agent-scout.md"
  "agents/os-tk-agent-quality.md"
  "agents/os-tk-agent-simplify.md"
  "commands/os-breakdown.md"
  "commands/os-change.md"
  "commands/os-proposal.md"
  "commands/tk-bootstrap.md"
  "commands/tk-done.md"
  "commands/tk-queue.md"
  "commands/tk-refactor.md"
  "commands/tk-review.md"
  "commands/tk-run.md"
  "commands/tk-start.md"
  "skills/openspec/SKILL.md"
  "skills/ticket/SKILL.md"
  "skills/os-tk-workflow/SKILL.md"
)

# Factory/Droid files
FACTORY_FILES=(
  "droids/os-tk-planner.md"
  "droids/os-tk-worker.md"
  "droids/os-tk-reviewer.md"
  "droids/os-tk-agent-spec.md"
  "droids/os-tk-agent-design.md"
  "droids/os-tk-agent-safety.md"
  "droids/os-tk-agent-scout.md"
  "droids/os-tk-agent-quality.md"
  "droids/os-tk-agent-simplify.md"
  "commands/os-breakdown.md"
  "commands/os-change.md"
  "commands/os-proposal.md"
  "commands/tk-bootstrap.md"
  "commands/tk-done.md"
  "commands/tk-queue.md"
  "commands/tk-refactor.md"
  "commands/tk-review.md"
  "commands/tk-run.md"
  "commands/tk-start.md"
  "skills/openspec/SKILL.md"
  "skills/ticket/SKILL.md"
  "skills/os-tk-workflow/SKILL.md"
)

# Pi files
PI_FILES=(
  "agents/os-tk-planner.md"
  "agents/os-tk-worker.md"
  "agents/os-tk-reviewer.md"
  "agents/os-tk-reviewer-agg-fast.md"
  "agents/os-tk-reviewer-agg-strong.md"
  "agents/os-tk-agent-spec.md"
  "agents/os-tk-agent-design.md"
  "agents/os-tk-agent-safety.md"
  "agents/os-tk-agent-scout.md"
  "agents/os-tk-agent-quality.md"
  "agents/os-tk-agent-simplify.md"
  "prompts/os-breakdown.md"
  "prompts/os-change.md"
  "prompts/os-proposal.md"
  "prompts/tk-bootstrap.md"
  "prompts/tk-done.md"
  "prompts/tk-queue.md"
  "prompts/tk-refactor.md"
  "prompts/tk-review.md"
  "prompts/tk-run.md"
  "prompts/tk-start.md"
  "skills/openspec/SKILL.md"
  "skills/ticket/SKILL.md"
  "skills/os-tk-workflow/SKILL.md"
)

# Default agent platforms (comma-separated)
DEFAULT_AGENTS="opencode"

# Parse --agent flag and return array of agents
parse_agents() {
  local input="${1:-$DEFAULT_AGENTS}"
  
  # Handle "all" keyword
  if [[ "$input" == "all" ]]; then
    echo "opencode,claude,factory,pi"
    return
  fi
  
  # Validate each agent
  local IFS=','
  for agent in $input; do
    case "$agent" in
      opencode|claude|factory|pi) ;;
      *)
        echo "Error: Unknown agent platform: $agent" >&2
        echo "Valid options: opencode, claude, factory, pi, all" >&2
        exit 1
        ;;
    esac
  done
  
  echo "$input"
}

# Get target directory for an agent platform (installed in project)
get_agent_dir() {
  local agent="$1"
  case "$agent" in
    opencode)  echo ".opencode" ;;
    claude)    echo ".claude" ;;
    factory)   echo ".factory" ;;
    pi)        echo ".pi" ;;
    *)
      echo "Error: Unknown agent: $agent" >&2
      return 1
      ;;
  esac
}

# Get source directory in template repo for an agent platform
get_template_dir() {
  local agent="$1"
  case "$agent" in
    opencode)  echo "opencode" ;;
    claude)    echo "claude" ;;
    factory)   echo "factory" ;;
    pi)        echo "pi" ;;
    *)
      echo "Error: Unknown agent: $agent" >&2
      return 1
      ;;
  esac
}

# Get file array for an agent platform
get_agent_files() {
  local agent="$1"
  case "$agent" in
    opencode)  echo "${OPENCODE_FILES[@]}" ;;
    claude)    echo "${CLAUDE_FILES[@]}" ;;
    factory)   echo "${FACTORY_FILES[@]}" ;;
    pi)        echo "${PI_FILES[@]}" ;;
    *)
      echo "Error: Unknown agent: $agent" >&2
      return 1
      ;;
  esac
}

# Sync files for a single agent platform
sync_agent_platform() {
  local agent="$1"
  local base_url="$2"
  
  local target_dir template_dir
  target_dir=$(get_agent_dir "$agent")
  template_dir=$(get_template_dir "$agent")
  
  echo "Syncing $agent → $target_dir/ (source: $template_dir/)"
  
  # Get file list based on agent
  local files
  case "$agent" in
    opencode)  files=("${OPENCODE_FILES[@]}") ;;
    claude)    files=("${CLAUDE_FILES[@]}") ;;
    factory)   files=("${FACTORY_FILES[@]}") ;;
    pi)        files=("${PI_FILES[@]}") ;;
  esac
  
  # Create all required directories
  for file in "${files[@]}"; do
    local dir
    dir=$(dirname "$target_dir/$file")
    mkdir -p "$dir"
  done
  
  # Download files
  local failed=0
  for file in "${files[@]}"; do
    local url="$base_url/$template_dir/$file"
    local dest="$target_dir/$file"
    
    if curl -sSfL "$url" -o "$dest" 2>/dev/null; then
      echo "  [ok] $dest"
    else
      # Fallback to hidden directory for older template tags
      local fallback_url="$base_url/.$template_dir/$file"
      if curl -sSfL "$fallback_url" -o "$dest" 2>/dev/null; then
         echo "  [ok] $dest (from fallback .$template_dir/)"
      else
        echo "  [FAIL] $dest"
        ((failed++)) || true
      fi
    fi
  done
  
  if [[ $failed -gt 0 ]]; then
    echo "  Warning: $failed file(s) failed for $agent"
  fi
  
  return $failed
}

cmd_sync() {
  check_dependencies
  
  local agents_input="$DEFAULT_AGENTS"
  
  # Parse flags
  while [[ $# -gt 0 ]]; do
    case "$1" in
      --agent|-a)
        agents_input="$2"
        shift 2
        ;;
      *)
        echo "Unknown option for sync: $1"
        usage
        ;;
    esac
  done
  
  local agents
  agents=$(parse_agents "$agents_input")
  
  local config
  config=$(load_config)
  
  local repo
  repo=$(get_config_value "$config" '.templateRepo' 'legout/openspec-ticket-opencode-starter')
  
  local ref
  ref=$(resolve_template_ref "$config")
  
  local base_url="https://raw.githubusercontent.com/$repo/$ref"
  
  echo "Syncing from $repo@$ref"
  echo "Agents: $agents"
  echo ""
  
  # Sync each selected agent platform
  local total_failed=0
  local IFS=','
  for agent in $agents; do
    sync_agent_platform "$agent" "$base_url"
    ((total_failed += $?)) || true
    echo ""
  done
  
  if [[ $total_failed -gt 0 ]]; then
    echo "Warning: Some files failed to download."
    echo "Check that templateRef '$ref' exists and contains all required files."
  fi
  
  echo "Sync complete."
  
  # Also update AGENTS.md block
  echo ""
  update_agents_md
}

# =============================================================================
# AGENTS.MD: Update the OS-TK block
# =============================================================================
AGENTS_BLOCK='<!-- OS-TK-START -->
# Agent Workflow: OpenSpec + Ticket (tk)

This repo uses OpenSpec for spec-driven changes and tk for task execution tracking.

## Core Rules

1. **Specs before code** - Create an OpenSpec proposal before implementing.
2. **One change = one epic** - Create a tk epic with `--external-ref "openspec:<change-id>"`.
3. **3-8 chunky tickets** - Break work into deliverables (DB/API/UI/tests/docs).
4. **Queue-driven execution** - Pick work via `tk ready`, never blind implementation.
5. **`/tk-done` is mandatory** - Always use `/tk-done` to close work (syncs tasks + archives + merges + pushes).

## Commands

| Command | Purpose |
|---------|---------|
| `/os-breakdown <source> [--with-tickets]` | Break down PRD/plan into OpenSpec proposals |
| `/os-proposal <id>` | Create/update OpenSpec change files |
| `/os-change [id]` | View change status (view-only) |
| `/tk-bootstrap <change-id> "<title>"` | Create tk epic + tasks from OpenSpec change |
| `/tk-queue [next\\|all\\|<change-id>]` | Show ready/blocked tickets (view-only) |
| `/tk-start <id...> [--parallel N]` | Start ticket(s) and implement |
| `/tk-done <id> [change-id]` | Close + sync + archive + merge + push |
| `/tk-review <id>` | Review completed ticket, create fix tickets if needed |
| `/tk-run [--all] [--max-cycles N]` | Autonomous loop: start → done → review → repeat |
| `/tk-refactor` | Merge duplicates, clean up backlog (optional) |

## Specialized Advisors (Advise-only)

Call these agents manually to get expert guidance at any stage. They can research via the web but cannot edit files.

| Agent | Expertise |
|-------|-----------|
| `@agent-spec` | Requirements, acceptance criteria, and edge cases |
| `@agent-design` | Architecture, dependencies, and rollout risk |
| `@agent-safety` | Security, privacy, and performance hotspots |
| `@agent-scout` | Tech research, API usage, and reference patterns |
| `@agent-quality` | Test strategy and verification checklists |
| `@agent-simplify` | Complexity reduction and refactoring advice |

## Review Automation

- `/tk-review` analyzes merge commits against OpenSpec specs
- Creates linked fix tickets (non-blocking) for issues found
- Configure via `reviewer` section in `config.json`
- `/tk-run` enables fully autonomous operation (Ralph mode)

## Parallel Execution

- **Safe mode** (`useWorktrees: true`): Parallel via git worktrees, isolated branches.
- **Simple mode** (`useWorktrees: false`): Single working tree; parallel only if `unsafe.allowParallel: true`.

Configure via `config.json`. Initialize with `os-tk init`.
<!-- OS-TK-END -->'

update_agents_md() {
  echo "Updating AGENTS.md..."
  
  if [[ ! -f "$AGENTS_FILE" ]]; then
    echo "  Creating new AGENTS.md"
    echo "$AGENTS_BLOCK" > "$AGENTS_FILE"
    return
  fi
  
  local content
  content=$(cat "$AGENTS_FILE")
  
  # Check for new markers
  if grep -qF "$MARKER_START" "$AGENTS_FILE"; then
    echo "  Replacing existing OS-TK block"
    # Remove old block and append new one
    perl -i -0pe "s/\Q$MARKER_START\E.*?\Q$MARKER_END\E//gs" "$AGENTS_FILE"
    # Remove trailing blank lines then append
    sed -i -e :a -e '/^\n*$/{$d;N;ba' -e '}' "$AGENTS_FILE" 2>/dev/null || true
    echo "" >> "$AGENTS_FILE"
    echo "$AGENTS_BLOCK" >> "$AGENTS_FILE"
    return
  fi
  
  # Check for legacy markers (migration)
  if grep -qF "$LEGACY_MARKER_START" "$AGENTS_FILE"; then
    echo "  Migrating from legacy OPENSPEC-TK markers to OS-TK markers"
    perl -i -0pe "s/\Q$LEGACY_MARKER_START\E.*?\Q$LEGACY_MARKER_END\E//gs" "$AGENTS_FILE"
    sed -i -e :a -e '/^\n*$/{$d;N;ba' -e '}' "$AGENTS_FILE" 2>/dev/null || true
    echo "" >> "$AGENTS_FILE"
    echo "$AGENTS_BLOCK" >> "$AGENTS_FILE"
    return
  fi
  
  # No markers exist - append
  echo "  Appending OS-TK block"
  echo "" >> "$AGENTS_FILE"
  echo "$AGENTS_BLOCK" >> "$AGENTS_FILE"
}

# =============================================================================
# APPLY: Regenerate agent files from config (no network, no AGENTS.md)
# =============================================================================
rebuild_agent_from_template() {
  local agent_file="$1"
  local role="$2"
  local model="$3"
  local temperature="$4"
  local reasoning_effort="$5"
  
  # Different permissions for each role
  local edit_perm="allow"
  local write_perm="allow"
  if [[ "$role" == "planner" ]]; then
    # Planner can create tickets (edit AGENTS.md) but contract restricts code editing
    edit_perm="allow"
    write_perm="allow"
  elif [[ "$role" == "reviewer" ]]; then
    # Reviewer can run tk commands but not edit code files
    edit_perm="deny"
    write_perm="deny"
  elif [[ "$role" == agent-* ]]; then
    # Specialized advisors are read-only
    edit_perm="deny"
    write_perm="deny"
  fi
  
  # Build optional reasoningEffort line (skip if empty, null, or "none")
  local reasoning_line=""
  local lower_effort
  lower_effort=$(echo "$reasoning_effort" | tr '[:upper:]' '[:lower:]')
  if [[ -n "$reasoning_effort" && "$reasoning_effort" != "null" && "$lower_effort" != "none" ]]; then
    reasoning_line="reasoningEffort: ${reasoning_effort}"
  fi
  
  cat > "$agent_file" << AGENT
---
name: os-tk-${role}
description: OpenSpec + ticket ${role} (view-only vs execution)
model: ${model}
mode: subagent
temperature: ${temperature}
${reasoning_line}
permission:
  bash: allow
  skill: allow
  edit: ${edit_perm}
  write: ${write_perm}
---

# OpenSpec + Ticket ${role}

You implement the ${role} phase of the workflow.

AGENT

  if [[ "$role" == "planner" ]]; then
    cat >> "$agent_file" << 'AGENT'

You coordinate **planning, bootstrapping, and orchestration** phases of the workflow. You **NEVER implement code** but you CAN create tickets and spawn worker subtasks.

## Core Responsibilities

1. **Planning** - Analyze specs, view status, recommend actions
2. **Bootstrapping** - Design and create 3-8 chunky tickets per epic
3. **Orchestration** - Spawn parallel worker subtasks for execution

## Command Precedence

When invoked via a command (e.g., `/os-change`, `/tk-queue`, `/tk-bootstrap`):
- The command markdown file is the HIGHEST PRIORITY contract.
- If any conflict between this description, skills, or general rules and the command's contract:
  - **The command contract wins. Always.**
- If a command says STOP -> you STOP.

## Allowed Actions

| Category | Commands |
|----------|----------|
| **OpenSpec** | `openspec list`, `openspec show <id>`, `openspec validate <id>` |
| **Tickets (read)** | `tk ready`, `tk blocked`, `tk show <id>`, `tk query <filter>` |
| **Tickets (write)** | `tk create`, `tk dep`, `tk link` |
| **AGENTS.md** | Edit **only within** `<!-- OS-TK-START -->` / `<!-- OS-TK-END -->` markers |
| **Subtasks** | Spawn `os-tk-worker` subtasks for parallel execution |
| **Analysis** | Summarize, analyze, recommend |

## Forbidden Actions

- \`tk start\`, \`tk close\`, \`tk add-note\` (those belong to worker or /tk-done)
- Editing code files (*.py, *.ts, *.js, *.go, etc.)
- Editing config files (*.json, *.yaml, etc.) except AGENTS.md markers
- Implementing features or writing application code
- Archiving OpenSpec (handled by /tk-done)
- Running tests

## Ticket Design Guidelines

When bootstrapping (/tk-bootstrap), create 3-8 chunky tickets:

| Layer | Example Ticket |
|-------|----------------|
| Data | "Database schema for User entity" |
| Backend | "User CRUD API endpoints" |
| Frontend | "User management UI components" |
| Integration | "Connect user forms to API" |
| Tests | "E2E tests for user workflows" |
| Docs | "API documentation for users" |

## Parallel Worker Spawning

For commands like `/tk-start T-001 T-002 --parallel 2`:
1. Validate tickets are ready via `tk ready`
2. Spawn one `os-tk-worker` subtask per ticket
3. Each worker operates in its own worktree (if enabled)
4. Report status when all workers complete

## Self-Check (Before Responding)

Before responding, confirm you did NOT:
- [ ] Write or suggest implementation code
- [ ] Propose running `tk start` or `tk close` directly
- [ ] Edit code files or config files (except AGENTS.md markers)

If you violated any, remove it and redirect to `/tk-start` or `/tk-done`.

## Worktree Awareness

- Exclude active worktrees (`.worktrees/<id>/`) from "ready to start" lists
- When `useWorktrees` is false, all "ready" tickets are eligible
AGENT

  elif [[ "$role" == "worker" ]]; then
    cat >> "$agent_file" << 'AGENT'

You implement **ticket deliverables and acceptance criteria** within isolated contexts.

## Core Rules

- Implement exactly one ticket per invocation.
- Run tests to validate implementation.
- Do NOT close tickets (that is `/tk-done`'s job).
- Do NOT archive OpenSpec (that is `/tk-done`'s job).
- Do NOT merge branches or push (those are `/tk-done`'s job).
- Edit OpenSpec `tasks.md` only as directed by planner/`/tk-done` sync.

## Allowed Actions

- Edit files, write code, refactor as needed.
- Run tests and fix failures.
- Read `tk show <id>` for ticket context.

## Forbidden Actions

- Closing tickets (`tk close`)
- Archiving OpenSpec
- Merging branches or pushing
- Editing OpenSpec `tasks.md` (that is planner/`/tk-done`'s sync job)
- Implementing multiple tickets in one flow

## Worktree Awareness

- When `useWorktrees` is true, you operate in an isolated worktree: `.worktrees/<ticket-id>/`.
- When `useWorktrees` is false, you operate in the current working tree.

## Output

When implementation is complete:
- Summarize what was implemented.
- List any files created/modified.
- Explicitly instruct the user to run `/tk-done <id> [change-id]`.
AGENT

  elif [[ "$role" == "reviewer" ]]; then
    cat >> "$agent_file" << 'AGENT'

You perform **post-implementation code review** analyzing completed work for quality issues.

## Core Rules

- Analyze git diffs and compare against OpenSpec specs.
- Add review notes to tickets via `tk add-note`.
- Create fix tickets via `tk create` and link them via `tk link`.
- Never edit code files directly.
- Never close tickets or start implementation.

## Review Categories

1. **spec-compliance**: Does implementation match OpenSpec requirements?
2. **tests**: Are acceptance criteria covered by tests?
3. **security**: Obvious vulnerabilities (injection, auth, secrets)
4. **quality**: Code patterns, DRY violations, error handling

## Allowed Actions

- Read all files, specs, and ticket data
- `git diff`, `git log`, `git show` to analyze changes
- `tk add-note <id>` to add review summary
- `tk create` to create fix tickets
- `tk link` to link fix tickets to originals
- `openspec show`, `openspec list` to read specs

## Forbidden Actions

- Editing code files (*.py, *.ts, *.js, etc.)
- `tk start`, `tk close`
- Implementing fixes (that's the worker's job)
- Archiving OpenSpec

## Output Format

Review notes should follow this format:

```markdown
## Review (YYYY-MM-DD)
✅ spec-compliance: passed
⚠️ tests: Missing edge case test for null input
❌ security: SQL injection risk in query builder

Created: T-XXX (linked)
```

    When review is complete:
- Summarize findings by category
- List any fix tickets created
- If no issues: "Review passed, no issues found"
AGENT

  elif [[ "$role" == "agent-spec" ]]; then
    cat >> "$agent_file" << 'AGENT'

You are the **Spec Companion**. Your role is to ensure requirements are crisp, complete, and unambiguous.

## Core Responsibilities

1. **Requirements Clarification**: Identify fuzzy requirements and suggest precise acceptance criteria.
2. **Edge Case Discovery**: Spot missing scenarios, error conditions, and boundary cases.
3. **User Story Refinement**: Improve user stories with clear "Definition of Done".
4. **Consistency Check**: Ensure new requirements don't conflict with existing ones in `openspec/specs/`.

## Your Advice Contract

- **Advise Only**: You provide recommendations, structured feedback, and questions.
- **Never Write**: You must NOT edit any files, create tickets, or run implementation commands.
- **Web Research**: Use web search to research industry standards, common requirements for similar features, and accessibility best practices.

## Suggested Next Steps
After providing your advice, suggest which OpenSpec capability needs updating or which human clarification is required.
AGENT

  elif [[ "$role" == "agent-design" ]]; then
    cat >> "$agent_file" << 'AGENT'

You are the **Design & Risk Advisor**. Your role is to provide technical guidance on architecture, dependencies, and rollout strategies.

## Core Responsibilities

1. **Architecture Alignment**: Propose architectural patterns that match project conventions.
2. **Dependency Analysis**: Identify hidden dependencies, sequencing issues, and potential blockers.
3. **Rollout Strategy**: Advise on feature flags, migrations, and backward compatibility.
4. **Risk Assessment**: Spot technical "footguns", rollout hazards, and sequencing risks.

## Your Advice Contract

- **Advise Only**: You provide technical rationale, tradeoffs, and proposed ADR-lite decisions.
- **Never Write**: You must NOT edit any files, create tickets, or run implementation commands.
- **Web Research**: Use web search to research library documentation, architectural patterns (ADRs), and version compatibility.

## Suggested Next Steps
Recommend a sequence for implementation tickets (e.g., "DB first, then API") or suggest a specific technical decision to be recorded.
AGENT

  elif [[ "$role" == "agent-safety" ]]; then
    cat >> "$agent_file" << 'AGENT'

You are the **Safety & Perf Reviewer**. Your role is to threat-model the change and identify performance bottlenecks.

## Core Responsibilities

1. **Security Review**: Identify SQL injection, XSS, hardcoded secrets, and authz/authn gaps.
2. **Privacy Audit**: Spot PII exposure, logging of sensitive data, and data retention issues.
3. **Performance Analysis**: Identify N+1 queries, unbounded loops, and expensive operations.
4. **Cost Awareness**: Spot "cost footguns" (e.g., excessive API calls, large cloud resource needs).

## Your Advice Contract

- **Advise Only**: You provide a risk register, security/perf mitigations, and explicit acceptance criteria for safety.
- **Never Write**: You must NOT edit any files, create tickets, or run implementation commands.
- **Web Research**: Use web search to research CVEs, security best practices (OWASP), and performance benchmarks for libraries.

## Suggested Next Steps
Suggest specific "Safety Scenarios" to add to the OpenSpec proposal or performance limits to enforce in tests.
AGENT

  elif [[ "$role" == "agent-scout" ]]; then
    cat >> "$agent_file" << 'AGENT'

You are the **Implementation Scout**. Your role is to research APIs, libraries, and best practices to accelerate implementation.

## Core Responsibilities

1. **Tech Research**: Find the best way to use a library or API based on latest documentation.
2. **Pattern Matching**: Identify common integration patterns and known pitfalls for the tech stack.
3. **Reference Snippets**: Provide minimal, idiomatic code examples (advisory only) for the worker to adapt.
4. **Version Scouting**: Check for deprecations, breaking changes, or better alternatives in newer versions.

## Your Advice Contract

- **Advise Only**: You provide research summaries, reference links, and implementation "recipes".
- **Never Write**: You must NOT edit any files, create tickets, or run implementation commands.
- **Web Research**: Use web search to research API documentation, GitHub examples, and StackOverflow solutions.

## Suggested Next Steps
Provide a list of "recipes" or documentation links that the worker should follow during implementation.
AGENT

  elif [[ "$role" == "agent-quality" ]]; then
    cat >> "$agent_file" << 'AGENT'

You are the **Quality Strategist**. Your role is to design a comprehensive testing and verification plan.

## Core Responsibilities

1. **Test Matrix**: Advise on what to test at unit, integration, and E2E levels.
2. **Scenario Coverage**: Ensure all OpenSpec scenarios have corresponding test ideas.
3. **Verification Checklist**: Provide a "manual verification" checklist for things hard to automate.
4. **Observability**: Suggest logging, tracing, and metrics needed to verify the feature in production.

## Your Advice Contract

- **Advise Only**: You provide a test strategy, coverage gaps, and explicit "How to Verify" checklists.
- **Never Write**: You must NOT edit any files, create tickets, or run implementation commands.
- **Web Research**: Use web search to research testing patterns, mock strategies, and observability tools.

## Suggested Next Steps
Suggest specific test tickets to be added to the epic or acceptance criteria to be clarified.
AGENT

  elif [[ "$role" == "agent-simplify" ]]; then
    cat >> "$agent_file" << 'AGENT'

You are the **Code Simplification Specialist**. Your role is to enhance code clarity, consistency, and maintainability while preserving exact functionality.

## Core Principles

1. **Preserve Functionality First**: Never change what the code does - only how it does it. All original features, outputs, and behaviors must remain intact.

2. **Focus on Recent Changes**: Prioritize simplification of recently modified code or code touched in the current implementation. Unless explicitly instructed, do not review unrelated legacy code.

3. **Apply Project Standards**: Ensure code follows established project conventions:
   - Language-specific idioms and patterns
   - Consistent naming conventions
   - Proper error handling patterns
   - Appropriate abstraction levels

4. **Enhance Clarity**:
   - Reduce unnecessary complexity and nesting
   - Eliminate redundant code and harmful abstractions
   - Improve readability through clear variable and function names
   - Consolidate related logic
   - Remove unnecessary comments that describe obvious code
   - **Avoid nested ternary operators** - prefer switch statements or if/else chains
   - Choose clarity over brevity - explicit code is often better than overly compact code

5. **Maintain Balance**: Avoid over-simplification that could:
   - Reduce code clarity or maintainability
   - Create overly clever solutions that are hard to understand
   - Combine too many concerns into single functions
   - Remove helpful abstractions that improve code organization
   - Prioritize "fewer lines" over readability
   - Make the code harder to debug or extend

## Your Analysis Process

1. **Identify**: Focus on recently modified code sections or code explicitly brought to your attention
2. **Analyze**: Look for opportunities to improve elegance and consistency
3. **Apply**: Suggest project-specific best practices and coding standards
4. **Verify**: Ensure all functionality remains unchanged
5. **Check**: Confirm the refined code is simpler and more maintainable
6. **Document**: Highlight only significant changes that affect understanding

## Your Advice Contract

- **Advise Only**: You provide simplification suggestions, complexity hotspots, and refactoring rationales.
- **Never Write**: You must NOT edit any files, create tickets, or run implementation commands.
- **Web Research**: Use web search to research clean code principles, refactoring patterns, and language-specific idioms.

## Suggested Next Steps
Suggest specific refactoring steps or a "Cleanup" ticket for files that need simplification attention. Focus on recently implemented code that would benefit from immediate simplification.
AGENT


  else
    echo "Error: Unknown role: $role"
    exit 1
  fi
}

rebuild_aggregator_from_template() {
  local agent_file="$1"
  local type="$2" # "fast" or "strong"
  local model="$3"
  local temperature="$4"
  local reasoning_effort="$5"
  
  local reasoning_line=""
  local lower_effort
  lower_effort=$(echo "$reasoning_effort" | tr '[:upper:]' '[:lower:]')
  if [[ -n "$reasoning_effort" && "$reasoning_effort" != "null" && "$lower_effort" != "none" ]]; then
    reasoning_line="reasoningEffort: ${reasoning_effort}"
  fi
  
  cat > "$agent_file" << AGENT
---
name: os-tk-reviewer-agg-${type}
description: OpenSpec + ticket review aggregator (${type})
model: ${model}
mode: subagent
temperature: ${temperature}
${reasoning_line}
permission:
  bash: allow
  bash: "tk show *"
  bash: "tk add-note *"
  bash: "tk create *"
  bash: "tk link *"
  bash: "git *"
  skill: allow
  read: allow
  glob: allow
  grep: allow
  edit: deny
  write: deny
---

# Review Aggregator (${type})

You are the **aggregator** for the multi-model code review pipeline. Your job is to merge findings from multiple "scout" models into a single, high-quality review.

## Your Exclusivity

- **ONLY YOU** are allowed to create fix tickets (\`tk create\`).
- **ONLY YOU** are allowed to add notes to the original ticket (\`tk add-note\`).
- Scouts are strictly forbidden from these actions.

## Allowed Actions

You may call these \`tk\` commands:
- \`tk show <id>\` - read ticket info
- \`tk add-note <id> <text>\` - add review notes
- \`tk create "Fix: <title>" --parent <epic-id> --description "<desc>"\` - create fix tickets
- \`tk link <new-id> <ticket-id>\` - link fix tickets to reviewed ticket

**Forbidden** \`tk\` commands:
- \`tk close\`, \`tk start\`, \`tk status\` - do not advance workflow state

## Hybrid Filtering Logic

Before creating tickets, apply **hybrid filtering** to reduce false positives:

### Step 1: Collect Config
Read \`.os-tk/config.json\` (or fallback \`config.json\`) to get:
- \`reviewer.requireSeverity\` - array of severities (default: ["error"])
- \`reviewer.requireConfidence\` - integer threshold (default: 80)
- \`reviewer.hybridFiltering\` - boolean (default: true)

### Step 2: Evaluate Each Finding

For each merged finding:

\`\`\`bash
# Check severity threshold
severity_pass = false
if finding.severity in config.requireSeverity:
  severity_pass = true

# Check confidence threshold
confidence_pass = false
if finding.confidence >= config.requireConfidence:
  confidence_pass = true

# Apply hybrid filter
if config.hybridFiltering:
  # BOTH must pass
  if severity_pass AND confidence_pass:
    CREATE_TICKET = true
  else:
    CREATE_TICKET = false
    LOG_SKIPPED(finding, severity_pass, confidence_pass)
else:
  # Legacy mode: severity only
  if severity_pass:
    CREATE_TICKET = true
  else:
    CREATE_TICKET = false
\`\`\`

### Step 3: Handle Guardrails

When \`error\` has confidence < requireConfidence:
- If confidence >= (requireConfidence - 10): Downgrade to \`warning\`, include in note
- If confidence < (requireConfidence - 10): Skip entirely, include in skipped table

This prevents \`error\` findings with low confidence (likely false positives) from creating tickets.

## Your Workflow

1. **Collect**: Read the structured outputs (envelopes) from all scouts.
2. **Merge**: Deduplicate findings based on category, file, title, and line ranges.
3. **Resolve**: 
   - Set final severity to the **MAX** reported by any scout.
   - Set final confidence to the **MIN** reported by any scout (conservative).
   - Attach "sources" (which scouts found it) to each merged finding.
   - Attach "agreement count" (e.g., "2/3 scouts flagged this").
4. **Filter**: Apply hybrid filtering logic (see above).
5. **Execute**:
   - Call \`tk add-note\` with the consolidated summary (including skipped findings).
   - Call \`tk create\` and \`tk link\` for each finding that passes hybrid filter.

## Consolidated Note Format

\`\`\`markdown
## Review Summary (YYYY-MM-DD)
Consolidated review from \${scout_count} models.

### Findings (passed hybrid filter: severity=\`error\`, confidence>=80)
| Category | Severity | Confidence | Finding | Sources |
|----------|----------|------------|---------|---------|
| security | error | 85 | Missing auth check | spec-audit, shallow-bugs |
| quality | error | 90 | TODO not addressed | code-comments, history-context |

### Skipped (failed threshold)
| Category | Severity | Confidence | Reason |
|----------|----------|------------|--------|
| quality | warning | 65 | Severity not in createTicketsFor |
| spec-compliance | error | 70 | Confidence below threshold (80) |

Created: T-XXX, T-YYY (linked)
\`\`\`

AGENT
}

rebuild_scout_from_template() {
  local agent_file="$1"
  local scout_role="$2"
  local model="$3"
  local temperature="$4"
  local reasoning_effort="$5"
  
  local reasoning_line=""
  local lower_effort
  lower_effort=$(echo "$reasoning_effort" | tr '[:upper:]' '[:lower:]')
  if [[ -n "$reasoning_effort" && "$reasoning_effort" != "null" && "$lower_effort" != "none" ]]; then
    reasoning_line="reasoningEffort: ${reasoning_effort}"
  fi
  
  cat > "$agent_file" << AGENT
---
name: os-tk-reviewer-scout-${scout_role}
description: OpenSpec + ticket review scout (${scout_role})
model: ${model}
mode: subagent
temperature: ${temperature}
${reasoning_line}
permission:
  bash: allow
  bash: "git *"
  skill: allow
  read: allow
  glob: allow
  grep: allow
  edit: deny
  write: deny
---

# Review Scout (${scout_role})

You are a **read-only scout** in a multi-model code review pipeline.

## Scout Role

**Role:** \`${scout_role}\`

## YOUR CONTRACT (STRICT)

1. **FORBIDDEN**: You must **NEVER** call \`tk add-note\`, \`tk create\`, \`tk link\`, \`tk close\`, or \`tk start\`.
2. **FORBIDDEN**: You must **NEVER** edit any files.
3. **FORBIDDEN**: You must **NEVER** write any files.
4. **REQUIRED**: You must output your findings in exactly one structured envelope with confidence scores.

## Output Envelope

You must end your response with exactly one block formatted as follows:

\`\`\`
@@OS_TK_SCOUT_RESULT_START@@
{
  "scoutId": "${scout_role}",
  "findings": [
    {
      "category": "spec-compliance|tests|security|quality",
      "severity": "error|warning|info",
      "confidence": 85,
      "falsePositiveCheck": "Brief rationale explaining why this is a real issue and not a false positive",
      "title": "Short title",
      "evidence": ["file:line", "file:line"],
      "description": "Clear description of the issue",
      "suggestedFix": ["Step 1", "Step 2"]
    }
  ]
}
@@OS_TK_SCOUT_RESULT_END@@
\`\`\`

## Confidence Scoring

You MUST assign a confidence score from 0-100 for each finding:
- **100**: Certain issue (will fail, clear violation, on modified lines only)
- **75**: High confidence (very likely real issue, strong evidence)
- **50**: Moderate confidence (possible issue, needs verification)
- **25**: Low confidence (might be issue, could be intentional)
- **0**: Not a real issue (false positive, pre-existing, intentional change)

## False Positive Detection

DO NOT report issues that are:
- Pre-existing (on lines you didn't modify)
- On unmodified files/lines
- Catchable by linters/typecheckers/compilers
- Pedantic style issues not in config categories
- Intentional changes related to ticket scope
- Suppressed by existing ignore/exception comments

## Analysis Goals

Compare the implementation (git diff) against requirements. Focus on accuracy and evidence.

AGENT
}

rebuild_reviewer_scouts() {
  local target_dir="$1"
  local config="$2"
  
  # Extract scouts array
  local scouts_json
  scouts_json=$(echo "$config" | jq -c '.reviewer.scouts // []')
  
  if [[ "$scouts_json" == "[]" ]]; then
    return
  fi
  
  echo "  - Generating reviewer scouts..."
  
  # Validate one-scout-per-role
  local count
  count=$(echo "$scouts_json" | jq '. | length')
  
  local seen_roles=""
  for ((i=0; i<count; i++)); do
    local scout role
    scout=$(echo "$scouts_json" | jq -c ".[$i]")
    role=$(echo "$scout" | jq -r '.role')
    
    # Check for duplicate roles
    if [[ ",$seen_roles," == *",$role,"* ]]; then
      echo "Error: Duplicate role '$role' in reviewer.scouts. Only one scout per role allowed." >&2
      echo "Config roles found: $seen_roles" >&2
      exit 1
    fi
    
    seen_roles="$seen_roles,$role"
  done
  
  # Generate scouts
  for ((i=0; i<count; i++)); do
    local scout role model temp reasoning
    scout=$(echo "$scouts_json" | jq -c ".[$i]")
    role=$(echo "$scout" | jq -r '.role')
    model=$(echo "$scout" | jq -r '.model')
    temp=$(echo "$scout" | jq -r '.temperature // 0')
    reasoning=$(echo "$scout" | jq -r '.reasoningEffort // "none"')
    
    rebuild_scout_from_template "$target_dir/agent/os-tk-reviewer-scout-${role}.md" "$role" "$model" "$temp" "$reasoning"
    echo "    [ok] os-tk-reviewer-scout-${role}.md"
  done
}

ensure_gitignore_worktrees() {
  local config="$1"
  local use_worktrees
  use_worktrees=$(get_config_value "$config" '.useWorktrees' 'false')
  
  if [[ "$use_worktrees" == "true" ]]; then
    local worktree_dir
    worktree_dir=$(get_config_value "$config" '.worktreeDir' '.worktrees')
    local gitignore_entry="${worktree_dir}/"
    
    if [[ ! -f ".gitignore" ]]; then
      echo "$gitignore_entry" > .gitignore
      echo "Created .gitignore with $gitignore_entry"
    elif ! grep -qF "$gitignore_entry" .gitignore 2>/dev/null; then
      echo "$gitignore_entry" >> .gitignore
      echo "Added $gitignore_entry to .gitignore"
    else
      echo "$gitignore_entry already in .gitignore"
    fi
  fi
}

check_pi_subagent_extension() {
  local extension_dir="$HOME/.pi/agent/extensions/subagent"
  if [[ ! -d "$extension_dir" ]]; then
    echo "Warning: Pi 'subagent' extension not found at $extension_dir"
    echo "To install it:"
    echo "  1. Clone https://github.com/badlogic/pi-mono"
    echo "  2. Copy/symlink 'packages/coding-agent/examples/extensions/subagent' to '$extension_dir'"
    echo "  3. Restart 'pi'"
    echo ""
  fi
}

cmd_apply() {
  check_dependencies
  
  local agents_input=""
  
  # Parse flags
  while [[ $# -gt 0 ]]; do
    case "$1" in
      --agent|-a)
        agents_input="$2"
        shift 2
        ;;
      *)
        echo "Unknown option for apply: $1"
        usage
        ;;
    esac
  done
  
  local config
  config=$(load_config)
  
  # Get agents from flag, config, or default
  if [[ -z "$agents_input" ]]; then
    agents_input=$(get_config_value "$config" '.agents' "$DEFAULT_AGENTS")
  fi
  
  local agents
  agents=$(parse_agents "$agents_input")
  
  echo "Applying config to agents: $agents"
  echo ""
  
  # Extract planner config
  local planner_model planner_temp planner_reasoning
  planner_model=$(get_config_value "$config" '.planner.model' 'openai/gpt-5.2')
  planner_temp=$(get_config_value "$config" '.planner.temperature' '0')
  planner_reasoning=$(get_config_value "$config" '.planner.reasoningEffort' '')
  
  # Extract worker config
  local worker_model worker_temp worker_reasoning
  worker_model=$(get_config_value "$config" '.worker.model' 'zai-coding-plan/glm-4.7')
  worker_temp=$(get_config_value "$config" '.worker.temperature' '0.2')
  worker_reasoning=$(get_config_value "$config" '.worker.reasoningEffort' '')
  
  # Extract reviewer config
  local reviewer_model reviewer_temp reviewer_reasoning
  reviewer_model=$(get_config_value "$config" '.reviewer.model' 'openai/gpt-5.2')
  reviewer_temp=$(get_config_value "$config" '.reviewer.temperature' '0')
  reviewer_reasoning=$(get_config_value "$config" '.reviewer.reasoningEffort' 'high')
  
  # Extract aggregator strong config
  local agg_strong_model agg_strong_temp agg_strong_reasoning
  agg_strong_model=$(get_config_value "$config" '.reviewer.aggregatorStrong.model' 'openai/gpt-5.2')
  agg_strong_temp=$(get_config_value "$config" '.reviewer.aggregatorStrong.temperature' '0')
  agg_strong_reasoning=$(get_config_value "$config" '.reviewer.aggregatorStrong.reasoningEffort' 'medium')
  
  # Apply to each selected agent platform
  local IFS=','
  for agent in $agents; do
    apply_agent_platform "$agent" \
      "$planner_model" "$planner_temp" "$planner_reasoning" \
      "$worker_model" "$worker_temp" "$worker_reasoning" \
      "$reviewer_model" "$reviewer_temp" "$reviewer_reasoning" \
      "$agg_strong_model" "$agg_strong_temp" "$agg_strong_reasoning" \
      "$config"
  done
  
  ensure_gitignore_worktrees "$config"
  
  echo ""
  echo "Config applied."
}

# Apply config to a specific agent platform
apply_agent_platform() {
  local agent="$1"
  local planner_model="$2" planner_temp="$3" planner_reasoning="$4"
  local worker_model="$5" worker_temp="$6" worker_reasoning="$7"
  local reviewer_model="$8" reviewer_temp="$9" reviewer_reasoning="${10}"
  local agg_strong_model="${11}" agg_strong_temp="${12}" agg_strong_reasoning="${13}"
  local config="${14}"
  
  local target_dir
  target_dir=$(get_agent_dir "$agent")
  
  echo "Applying to $agent → $target_dir/"
  
  case "$agent" in
    opencode)
      mkdir -p "$target_dir/agent"
      rebuild_agent_from_template "$target_dir/agent/os-tk-planner.md" "planner" "$planner_model" "$planner_temp" "$planner_reasoning"
      rebuild_agent_from_template "$target_dir/agent/os-tk-worker.md" "worker" "$worker_model" "$worker_temp" "$worker_reasoning"
      
      # Aggregators
      rebuild_aggregator_from_template "$target_dir/agent/os-tk-reviewer-agg-fast.md" "fast" "$worker_model" "$worker_temp" "$worker_reasoning"
      rebuild_aggregator_from_template "$target_dir/agent/os-tk-reviewer-agg-strong.md" "strong" "$agg_strong_model" "$agg_strong_temp" "$agg_strong_reasoning"
      
      # Keep os-tk-reviewer as aggregator-strong for backward compat/convenience
      rebuild_aggregator_from_template "$target_dir/agent/os-tk-reviewer.md" "strong" "$agg_strong_model" "$agg_strong_temp" "$agg_strong_reasoning"
      
      # Scouts
      rebuild_reviewer_scouts "$target_dir" "$config"
      
      # Advisors
      rebuild_agent_from_template "$target_dir/agent/os-tk-agent-spec.md" "agent-spec" "$planner_model" "$planner_temp" "$planner_reasoning"
      rebuild_agent_from_template "$target_dir/agent/os-tk-agent-design.md" "agent-design" "$planner_model" "$planner_temp" "$planner_reasoning"
      rebuild_agent_from_template "$target_dir/agent/os-tk-agent-safety.md" "agent-safety" "$planner_model" "$planner_temp" "$planner_reasoning"
      rebuild_agent_from_template "$target_dir/agent/os-tk-agent-scout.md" "agent-scout" "$planner_model" "$planner_temp" "$planner_reasoning"
      rebuild_agent_from_template "$target_dir/agent/os-tk-agent-quality.md" "agent-quality" "$planner_model" "$planner_temp" "$planner_reasoning"
      rebuild_agent_from_template "$target_dir/agent/os-tk-agent-simplify.md" "agent-simplify" "$planner_model" "$planner_temp" "$planner_reasoning"
      
      echo "  - $target_dir/agent/os-tk-planner.md (model: $planner_model)"
      echo "  - $target_dir/agent/os-tk-worker.md (model: $worker_model)"
      echo "  - $target_dir/agent/os-tk-reviewer-agg-fast.md (model: $worker_model)"
      echo "  - $target_dir/agent/os-tk-reviewer-agg-strong.md (model: $agg_strong_model)"
      ;;
    claude)
      # Claude Code uses different structure - agents are in agents/ dir
      mkdir -p "$target_dir/agents"
      rebuild_agent_from_template "$target_dir/agents/os-tk-planner.md" "planner" "$planner_model" "$planner_temp" "$planner_reasoning"
      rebuild_agent_from_template "$target_dir/agents/os-tk-worker.md" "worker" "$worker_model" "$worker_temp" "$worker_reasoning"
      rebuild_agent_from_template "$target_dir/agents/os-tk-reviewer.md" "reviewer" "$reviewer_model" "$reviewer_temp" "$reviewer_reasoning"
      
      # Advisors
      rebuild_agent_from_template "$target_dir/agents/os-tk-agent-spec.md" "agent-spec" "$planner_model" "$planner_temp" "$planner_reasoning"
      rebuild_agent_from_template "$target_dir/agents/os-tk-agent-design.md" "agent-design" "$planner_model" "$planner_temp" "$planner_reasoning"
      rebuild_agent_from_template "$target_dir/agents/os-tk-agent-safety.md" "agent-safety" "$planner_model" "$planner_temp" "$planner_reasoning"
      rebuild_agent_from_template "$target_dir/agents/os-tk-agent-scout.md" "agent-scout" "$planner_model" "$planner_temp" "$planner_reasoning"
      rebuild_agent_from_template "$target_dir/agents/os-tk-agent-quality.md" "agent-quality" "$planner_model" "$planner_temp" "$planner_reasoning"
      rebuild_agent_from_template "$target_dir/agents/os-tk-agent-simplify.md" "agent-simplify" "$planner_model" "$planner_temp" "$planner_reasoning"
      
      echo "  - $target_dir/agents/os-tk-planner.md"
      echo "  - $target_dir/agents/os-tk-worker.md"
      echo "  - $target_dir/agents/os-tk-reviewer.md"
      echo "  - $target_dir/agents/os-tk-agent-spec.md"
      echo "  - $target_dir/agents/os-tk-agent-design.md"
      echo "  - $target_dir/agents/os-tk-agent-safety.md"
      echo "  - $target_dir/agents/os-tk-agent-scout.md"
      echo "  - $target_dir/agents/os-tk-agent-quality.md"
      echo "  - $target_dir/agents/os-tk-agent-simplify.md"
      ;;
    factory)
      # Factory uses droids/ dir with reasoningEffort in frontmatter
      mkdir -p "$target_dir/droids"
      rebuild_agent_from_template "$target_dir/droids/os-tk-planner.md" "planner" "$planner_model" "$planner_temp" "$planner_reasoning"
      rebuild_agent_from_template "$target_dir/droids/os-tk-worker.md" "worker" "$worker_model" "$worker_temp" "$worker_reasoning"
      rebuild_agent_from_template "$target_dir/droids/os-tk-reviewer.md" "reviewer" "$reviewer_model" "$reviewer_temp" "$reviewer_reasoning"
      
      # Advisors
      rebuild_agent_from_template "$target_dir/droids/os-tk-agent-spec.md" "agent-spec" "$planner_model" "$planner_temp" "$planner_reasoning"
      rebuild_agent_from_template "$target_dir/droids/os-tk-agent-design.md" "agent-design" "$planner_model" "$planner_temp" "$planner_reasoning"
      rebuild_agent_from_template "$target_dir/droids/os-tk-agent-safety.md" "agent-safety" "$planner_model" "$planner_temp" "$planner_reasoning"
      rebuild_agent_from_template "$target_dir/droids/os-tk-agent-scout.md" "agent-scout" "$planner_model" "$planner_temp" "$planner_reasoning"
      rebuild_agent_from_template "$target_dir/droids/os-tk-agent-quality.md" "agent-quality" "$planner_model" "$planner_temp" "$planner_reasoning"
      rebuild_agent_from_template "$target_dir/droids/os-tk-agent-simplify.md" "agent-simplify" "$planner_model" "$planner_temp" "$planner_reasoning"
      
      echo "  - $target_dir/droids/os-tk-planner.md"
      echo "  - $target_dir/droids/os-tk-worker.md"
      echo "  - $target_dir/droids/os-tk-reviewer.md"
      echo "  - $target_dir/droids/os-tk-agent-spec.md"
      echo "  - $target_dir/droids/os-tk-agent-design.md"
      echo "  - $target_dir/droids/os-tk-agent-safety.md"
      echo "  - $target_dir/droids/os-tk-agent-scout.md"
      echo "  - $target_dir/droids/os-tk-agent-quality.md"
      echo "  - $target_dir/droids/os-tk-agent-simplify.md"
      ;;
    pi)
      mkdir -p "$target_dir/agents"
      
      # Best-effort model mapping
      rebuild_agent_from_template "$target_dir/agents/os-tk-planner.md" "planner" "$planner_model" "$planner_temp" "$planner_reasoning"
      rebuild_agent_from_template "$target_dir/agents/os-tk-worker.md" "worker" "$worker_model" "$worker_temp" "$worker_reasoning"
      
      # Aggregators
      rebuild_aggregator_from_template "$target_dir/agents/os-tk-reviewer-agg-fast.md" "fast" "$worker_model" "$worker_temp" "$worker_reasoning"
      rebuild_aggregator_from_template "$target_dir/agents/os-tk-reviewer-agg-strong.md" "strong" "$agg_strong_model" "$agg_strong_temp" "$agg_strong_reasoning"
      
      # Reviewer (aggregator-strong)
      rebuild_aggregator_from_template "$target_dir/agents/os-tk-reviewer.md" "strong" "$agg_strong_model" "$agg_strong_temp" "$agg_strong_reasoning"
      
      # Advisors for Pi
      rebuild_agent_from_template "$target_dir/agents/os-tk-agent-spec.md" "agent-spec" "$planner_model" "$planner_temp" "$planner_reasoning"
      rebuild_agent_from_template "$target_dir/agents/os-tk-agent-design.md" "agent-design" "$planner_model" "$planner_temp" "$planner_reasoning"
      rebuild_agent_from_template "$target_dir/agents/os-tk-agent-safety.md" "agent-safety" "$planner_model" "$planner_temp" "$planner_reasoning"
      rebuild_agent_from_template "$target_dir/agents/os-tk-agent-scout.md" "agent-scout" "$planner_model" "$planner_temp" "$planner_reasoning"
      rebuild_agent_from_template "$target_dir/agents/os-tk-agent-quality.md" "agent-quality" "$planner_model" "$planner_temp" "$planner_reasoning"
      rebuild_agent_from_template "$target_dir/agents/os-tk-agent-simplify.md" "agent-simplify" "$planner_model" "$planner_temp" "$planner_reasoning"
      
      # Scouts (in agents/ dir for Pi)
      # We need a Pi-specific version of rebuild_reviewer_scouts or adjust it
      # For now, let's just use the same logic but adjust target_dir
      PI_SCOUT_DIR="$target_dir/agents"
      
      # Manually call scout generation for Pi
      local scouts_json
      scouts_json=$(echo "$config" | jq -c '.reviewer.scouts // []')
      if [[ "$scouts_json" != "[]" ]]; then
        echo "  - Generating reviewer scouts for Pi..."
        local count
        count=$(echo "$scouts_json" | jq '. | length')
        for ((i=0; i<count; i++)); do
          local scout role model temp reasoning
          scout=$(echo "$scouts_json" | jq -c ".[$i]")
          role=$(echo "$scout" | jq -r '.role')
          model=$(echo "$scout" | jq -r '.model')
          temp=$(echo "$scout" | jq -r '.temperature // 0')
          reasoning=$(echo "$scout" | jq -r '.reasoningEffort // "none"')
          rebuild_scout_from_template "$PI_SCOUT_DIR/os-tk-reviewer-scout-${role}.md" "$role" "$model" "$temp" "$reasoning"
          echo "    [ok] os-tk-reviewer-scout-${role}.md"
        done
      fi
      
      echo "  - $target_dir/agents/os-tk-planner.md (model: $planner_model)"
      echo "  - $target_dir/agents/os-tk-worker.md (model: $worker_model)"
      
      echo "  Note: Models auto-mapped but may require manual adjustment in .pi/agents/*.md"
      check_pi_subagent_extension
      ;;
  esac

  echo ""
}

# =============================================================================
# INIT: Full initialization (sync + apply + AGENTS.md)
# =============================================================================
cmd_init() {
  check_dependencies
  
  local mode="worktree"  # default
  local agents_input="$DEFAULT_AGENTS"
  
  # Parse flags
  while [[ $# -gt 0 ]]; do
    case "$1" in
      --worktree|worktree)
        mode="worktree"
        shift
        ;;
      --simple|simple)
        mode="simple"
        shift
        ;;
      --agent|-a)
        agents_input="$2"
        shift 2
        ;;
      *)
        echo "Unknown option: $1"
        usage
        ;;
    esac
  done
  
  # Validate agents early
  local agents
  agents=$(parse_agents "$agents_input")
  
  # Create config if missing
  if [[ ! -f "$CONFIG_FILE" ]]; then
    default_config "$VERSION" "$agents" > "$CONFIG_FILE"
    echo "Created default config: $CONFIG_FILE"
  else
    echo "Config already exists: $CONFIG_FILE (preserving existing values)"
  fi
  
  # Store selected agents in config
  jq --arg agents "$agents" '.agents = $agents' "$CONFIG_FILE" > "${CONFIG_FILE}.tmp" && mv "${CONFIG_FILE}.tmp" "$CONFIG_FILE"
  
  # Apply mode
  if [[ "$mode" == "worktree" ]]; then
    echo "Enabling worktree mode (safe parallel)..."
    jq ".useWorktrees = true" "$CONFIG_FILE" > "${CONFIG_FILE}.tmp" && mv "${CONFIG_FILE}.tmp" "$CONFIG_FILE"
  elif [[ "$mode" == "simple" ]]; then
    echo "Enabling simple mode (no worktrees)..."
    jq ".useWorktrees = false" "$CONFIG_FILE" > "${CONFIG_FILE}.tmp" && mv "${CONFIG_FILE}.tmp" "$CONFIG_FILE"
  fi
  
  echo ""
  
  # Sync agent files from template
  cmd_sync --agent "$agents"
  
  echo ""
  
  # Apply config to agents
  cmd_apply --agent "$agents"
  
  echo ""
  
  # Update AGENTS.md
  update_agents_md
  
  echo ""
  echo "os-tk initialized!"
  echo ""
  echo "Selected agents: $agents"
  echo ""
  echo "Next steps:"
  echo "  1. Review and edit config.json to customize models/settings"
  echo "  2. Run: os-tk apply  (to regenerate agents after config changes)"
  
  # Build commit message based on selected agents
  local dirs="config.json AGENTS.md .gitignore"
  local IFS=','
  for agent in $agents; do
    local dir
    dir=$(get_agent_dir "$agent")
    dirs="$dirs $dir"
  done
  echo "  3. Commit: git add $dirs"
  echo ""
}

# =============================================================================
# VERSION
# =============================================================================
cmd_version() {
  echo "os-tk version $VERSION"
  
  if [[ -f "$CONFIG_FILE" ]]; then
    local config
    config=$(cat "$CONFIG_FILE")
    local template_ref
    template_ref=$(get_config_value "$config" '.templateRef' 'not set')
    local template_repo
    template_repo=$(get_config_value "$config" '.templateRepo' 'not set')
    echo ""
    echo "Project config:"
    echo "  templateRepo: $template_repo"
    echo "  templateRef:  $template_ref"
  fi
}

# =============================================================================
# USAGE
# =============================================================================
usage() {
  cat << EOF
os-tk — OpenSpec + Ticket workflow CLI

Usage: os-tk <command> [options]

Commands:
  init [options]          Initialize project (sync + apply + update AGENTS.md)
  sync [options]          Download agent files from templateRepo@templateRef
  apply [options]         Re-apply config to agents (no network, no AGENTS.md)
  version                 Show os-tk version and project templateRef

Agent Platforms:
  opencode                OpenCode format (.opencode/) - default
  claude                  Claude Code format (.claude/)
  factory                 Factory/Droid format (.factory/)
  pi                      Pi coding agent (.pi/)
  all                     All platforms

Options:
  --agent, -a <platforms> Comma-separated agent platforms (default: opencode)
  --worktree              Enable worktree mode for parallel execution (default)
  --simple                Disable worktrees, single working tree
  --version               Show version only
  --help                  Show this help

Config:
  Per-project config is stored in: config.json
  Set templateRef to a tag (e.g., "v1.0.0") or "latest" for newest release.

Examples:
  os-tk init                              # Initialize with OpenCode only
  os-tk init --agent opencode,claude      # Initialize for OpenCode + Claude Code
  os-tk init --agent all                  # Initialize for all platforms
  os-tk init --simple --agent claude      # Claude Code without worktrees
  os-tk sync --agent opencode,factory     # Update OpenCode + Factory files
  os-tk apply                             # Regenerate agents (uses config)
  os-tk apply --agent claude              # Regenerate Claude agents only

EOF
  exit 0
}

# =============================================================================
# MAIN
# =============================================================================
main() {
  local command="${1:-}"
  
  case "$command" in
    init)
      shift
      cmd_init "$@"
      ;;
    sync)
      shift
      cmd_sync "$@"
      ;;
    apply)
      shift
      cmd_apply "$@"
      ;;
    version)
      cmd_version
      ;;
    --version|-v)
      echo "os-tk $VERSION"
      ;;
    --help|-h|help|"")
      usage
      ;;
    *)
      echo "Unknown command: $command"
      echo ""
      usage
      ;;
  esac
}

main "$@"
